---
title: 浏览器渲染机制
date: 2025-08-12 15:34:02
tags: 浏览器
categories: 前端基础
cover: 
---

# 进程与线程的概念
## 进程：
    每个程序或 app 一旦允许则会形成一个进程，每个进程有自己独立的地址空间，一个进程无法访问其他进程的地址空间，进程直接如果要互相访问则需要用到进程间的通信。比如管道通信，套接字等。由此说进程是系统资源调用的最小单位
## 线程：
    一个进程可以有多个线程，每个线程使用所属进程的栈空间，同一个进程内的多个线程会共享部分状态，可以读写同一块内存。另外线程也有自己的寄存器和栈。其他线程可以读写这些栈和内存。由此说线程是进程的一个实体，是进程的某一条执行路径。当一个线程修改了进程的共享资源部分，其他线程也能感知资源发生变化。
## 补充：
在浏览器中每打开一个 tab 页相当于开了一个新的进程

# 浏览器的进程和线程
## Browse 主进程
1. 负责浏览器界面的显示以及一些与浏览器的交互，比如前进，后退，关闭某一个 tab 等
2. 负责各个页面的管理，比如创建和销毁（打开或关闭某一个 tab 页）
3. 同时负责将渲染进程加载到内存，绘制到用户界面
4. 另外负责网络资源的管理，下载等。
> 该进程始终只有一个
# Renderer 渲染进程（浏览器内核）
作用：主要负责解析 HTML、ＣＳＳ、执行 js等。  
关键特性：  
隔离性：每个标签页（或同一站点的多个标签页，取决于浏览器策略）通常对应一个独立的渲染进程。若某个标签页崩溃（如脚本死循环），不会影响其他标签页。
沙盒化：渲染进程运行在严格限制的沙盒环境中，无法直接访问操作系统或硬件（提升安全性）。
# GUI 渲染线程
● 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等
● 当界面需要重绘（repain）时或者回流（reflow），该线程就会执行
● 注意：GUI线程和JS引擎线程互斥！GUI线程和JS引擎线程互斥！GUI线程和JS引擎线程互斥！当JS引擎执行时，GUI线程就会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时，立即被执行。--- 这个地方会和后面连接起来叙述！！
> 小知识点：为什么JS引擎执行的时候GUI线程要被挂起？
因为JS是可以操作DOM的，而如果在修改这些元素的同时渲染界面，即当这两个线程不是互斥的时候，那么GUI渲染线程前后获得的元素数据就可能不一致。所以JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎线程空闲时立即被执行。
# JS 引擎线程
js 线程是单线程的，一个 Tab 中无论什么时候都只有一个 js 线程再运行程序，又因为 js 线程和 GUI 线程互斥，所以当某个 js 脚本执行的过久，会影响页面的渲染。由此一般script标签放在底部就是为了避免这种情况的发生，同时还可以加defer和async来修饰script标签，从而让dom渲染完成后再执行js脚本。
为什么 js 线程要被设计为单线程呢，是因为 js 本质用于处理与用户的交互等操作，用来操作dom元素。如果有多个线程，那么某个线程改掉一个 dom 元素，其他线程也更改这个 dom 元素会让浏览器处理变得复杂，比如：
想象两个线程同时操作同一个 DOM 元素：
线程 A 尝试修改 <div>的文本内容（div.textContent = "Hello"）；
线程 B 同时尝试删除该 <div>（div.remove()）。
此时，浏览器需要决定哪个操作先执行，或如何处理冲突（如部分修改被覆盖）。这种竞态条件（Race Condition）会导致不可预测的结果（如页面内容混乱、崩溃），而解决这类问题需要引入复杂的锁机制（如互斥锁、读写锁）：
每次操作 DOM 前加锁，操作完成后释放；
锁的管理会增加 JS 引擎的复杂度（如死锁检测、线程调度）；
开发者需要手动处理线程同步（如使用 lock关键字），这与 JS“简洁”的设计哲学相悖。
这种单线程的模式会有什么问题呢？
首先当要请求服务端事件的时候，所有后面的代码，比如一些 dom 操作等都会被阻塞，由此浏览器有了一些辅助 js 线程的其他兄弟线程，用于处理一些需要时间，或者条件触发之后再执行的代码，称为异步任务，这就是 js 的异步机制。
事件触发线程
● 事件触发线程归属于浏览器，而不是属于JS引擎，JS引擎处理的事务过多，需要浏览器另开线程来进行协助
● JS是采用事件驱动(event-driven)机制，来响应用户操作的，事件触发线程通过维护事件循环和事件队列等的方式，来响应和处理事件
● 当处理一些不能立即执行的函数或者其他的代码时，会将对应的任务在其可以触发的时机，添加到事件队列的末端。（事件循环机制，任务队列，宏任务队列，微任务队列）
● 事件循环机制会在JS引擎线程空闲时，循环访问事件队列的头部，如果有函数，则会将该函数推到执行栈中并立即执行。
定时器触发线程
即 setInterval 和 setTimeout所在的线程。
● 浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确性；
● 因此使用单独的一个线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；
● 注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。
异步 HTTP 请求线程
数量：多个
● XMLHttpRequest连接后通过浏览器新开一个线程请求；
● 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；

同步和异步的概念：
同步：代码一行行执行。
导致问题：当请求数据的时候会阻塞代码。
异步：把某些任务挂起来给兄弟线程去处理，处理完之后执行其回调函数，这样不会阻塞代码。
回调：定义一个函数暂时不用，需要某个事件或者时间触发


该进程的数量要根据打开的标签页数量和浏览器的进程合并策略来决定，通常一个标签页有一个进程
GPU 进程
1. 管理对图形的渲染，加速一些 css 样式和视频的播放。
2. 主要是把渲染进程生成的页面图层合成最终屏幕的图像
该进程一般最多只有一个
其他进程
网络进程
1. 用于管理网络请求，比如 http 请求或者 websocket 等。另外还管理一些 DNS 解析和缓存，代理相关。
通常只有一个，跨域的情况下可能会有辅助的网络进程
插件进程
1. 主要用来运行第三方插件，不过基本要废弃了
宏任务和微任务的概念
ES3 以前的版本是没有发起异步请求的能力，由此没有微任务的概念。ES6之后出现了Promise，从此不用浏览器也可以发起异步任务。
所以再浏览器环境中，由浏览器发起的是宏任务，比如：script，定时器，ajax请求，事件回调
由js自身发起的就是微任务，比如 promise 和 async/await

用一个例子来说明浏览器各个进程之间是如何协调合作的
Browser进程请求服务端，服务端返回了html资源
1. GUI渲染线程对html进行解析
2. 当解析到script标签时，JS引擎解析拿到的js代码，解析script标签就是最先进入执行栈的宏任务
3. 同上，但是事件队列就被区分为宏任务事件队列task queue，微任务事件队列microtask queue
  a. 为dom元素，添加事件 => 通过事件触发线程，生成事件监听器（待确认）=> 监听器监听到了用户触发事件的行为之后，将回调函数，推入task queue中
  b. 解析到setTimeout或者setInterval定时器代码时 => 通过定时器线程，开启定时任务 => 定时器时间到达之后，会将回调函数推入task queue中
  c. 遇到ajax请求 => 通过异步http请求线程，发送http请求 => 服务端返回响应后，会将成功或者失败的回调函数推入task queue中
  d. 代码中使用了Promise或者async/await来处理异步 => 处理完成后 => 推入microtask queue中
4. 当js执行线程中的代码执行完成之后，首先检查微任务队列头部是否有值，如果存在则将其推入到JS执行栈中执行，直到微任务队列头部为空。
5. 如果宿主是浏览器，GUI渲染线程可能会重新渲染页面
6. 然后检查宏任务队列头部是否有值，如果存在则将其推入到JS执行栈中执行，直到宏任务队列头部为空。
7. 当JS执行线程中的执行栈为空时，事件轮询机制会一直重复4-6这个循环
线程切换的顺序：
            =>  事件触发线程 
GUI渲染线程 => JS执行线程  =>  异步http线程 => 推到事件队列（事件触发线程） => GUI渲染线程(如果仍有等待的任务) => JS执行线程
            =>  定时器线程

浏览器渲染的前置条件
自己的理解：
从浏览器输入 URL 后，先找该 URL 在浏览器中有没有 DNS 缓存，然后找电脑里的 DNS 缓存，若都没有找到的情况下，根据策略去请求根 DNS 服务器，再由根 DNS 服务器去请求下面的其他服务器（这里有两种方式，有点不知道怎么描述了），总之请求完服务器后能够拿到对应 URL 对应的 IP 地址，根据 IP 地址，像对应 IP 对应端口的应用进程发起 TCP 连接，TCP 经历三次握手建立连接之后即可发送请求，得到响应的数据。然后再渲染。
具体查看《从输入 URL 到渲染出页面梳理》
单线程的浏览器引擎是如何实现并发的
综上所示，就是通过js线程以外的其他线程的辅助以及异步机制，回调函数的出现来实现。